# Декораторы и переадресация вызова, call/apply

JavaScript предоставляет исключительно гибкие возможности по работе с функциями: они могут быть переданы в другие функции, использованы как объекты, и сейчас мы рассмотрим, как перенаправлять вызовы между ними и как их декорировать.

## Прозрачное кеширование
Представим, что у нас есть функция slow(x), выполняющая ресурсоёмкие вычисления, но возвращающая стабильные результаты. Другими словами, для одного и того же x она всегда возвращает один и тот же результат.

Если функция вызывается часто, то, вероятно, мы захотим кешировать (запоминать) возвращаемые ею результаты, чтобы сэкономить время на повторных вычислениях.

Вместо того, чтобы усложнять slow(x) дополнительной функциональностью, мы заключим её в функцию-обёртку – «wrapper» (от англ. «wrap» – обёртывать), которая добавит кеширование.

## Перенаправление вызова
Передача всех аргументов вместе с контекстом другой функции называется «перенаправлением вызова» (call forwarding).

Простейший вид такого перенаправления:
```JavaScript
let wrapper = function() {
  return func.apply(this, arguments);
};
```
При вызове wrapper из внешнего кода его не отличить от вызова исходной функции.


## Заимствование метода

Пример: необходимо использовать методы реального массива, а объект arguments является перебираемым и псевдомассивом, но не реальным массивом.

Таким образом, вызов join для него потерпит неудачу, что мы можем сделать:
```JavaScript
[].join.call(arguments)
```
Этот трюк называется заимствование метода.

Мы берём (заимствуем) метод join из обычного массива [].join. И используем [].join.call, чтобы выполнить его в контексте arguments.

### Функция wrapper кеширования
```JavaScript
function cacheDecorator(func) {
  let cache = new Map();
  console.log('cache', cache);
  return function() {
    let key = hash(arguments); 
    if (cache.has(key)) {
      console.log('берем из кеша');
      return cache.get(key);
    }
    console.log('вычисляем и записываем в кеш');
    let result = func.call(this, ...arguments); 

    cache.set(key, result);
    return result;
  };
}

function hash(args) {
  return [].join.call(args)
}


let worker = {
  slow(min, max) {
    console.log(`Called with ${min},${max}`);
    return min + max;
  }
};

worker.slow = cacheDecorator(worker.slow, hash);

console.log( worker.slow(3, 5) ); // работает
console.log( "Again " + worker.slow(3, 5) ); // аналогично (из кеша)

```

## Итого
Декоратор – это обёртка вокруг функции, которая изменяет поведение последней. Основная работа по-прежнему выполняется функцией.

Обычно безопасно заменить функцию или метод декорированным, за исключением одной мелочи. Если исходная функция предоставляет свойства, такие как func.calledCount или типа того, то декорированная функция их не предоставит. Потому что это обёртка. Так что нужно быть осторожным в их использовании. Некоторые декораторы предоставляют свои собственные свойства.

Декораторы можно рассматривать как «дополнительные возможности» или «аспекты», которые можно добавить в функцию. Мы можем добавить один или несколько декораторов. И всё это без изменения кода оригинальной функции!

Для реализации cachingDecorator мы изучили методы:

- func.call(context, arg1, arg2…) – вызывает func с данным контекстом и аргументами.
- func.apply(context, args) – вызывает func, передавая context как this и псевдомассив args как список аргументов.

В основном переадресация вызова выполняется с помощью apply:

```JavaScript
let wrapper = function(original, arguments) {
  return original.apply(this, arguments);
};
```

Мы также рассмотрели пример заимствования метода, когда мы вызываем метод у объекта в контексте другого объекта. Весьма распространено заимствовать методы массива и применять их к arguments. В качестве альтернативы можно использовать объект с остаточными параметрами ...args, который является реальным массивом.

На практике декораторы используются для самых разных задач. 

## ПРИМЕРЫ

### Декоратор-шпион
декоратор spy(func), который должен возвращает обёртку, которая сохраняет все вызовы функции в своём свойстве calls.

Каждый вызов должен сохраняться как массив аргументов.
Этот декоратор иногда полезен для юнит-тестирования. Его расширенная форма – sinon.spy – содержится в библиотеке Sinon.JS.


```JavaScript
function spy(func) {

  function wrapper(...args) {
    // мы используем ...args вместо arguments для хранения "реального" массива в wrapper.calls
    wrapper.calls.push(args);
    return func.apply(this, args);
  }

  wrapper.calls = [];

  return wrapper;
}


// let spy = function(func) {
//   let calls = new Array();
  
//   return function() { 
//     calls.push({"call": [].join.call(arguments)});
//     //original.apply(this, arguments);
//     //return func.call(this, ...arguments); 
//     return func.apply(this, arguments);
//   }
// };

function work(a, b) {
  console.log(' work = ' , a + b ); // произвольная функция или метод
}

work = spy(work);

work(1, 2); // 3
work(4, 5); // 9
work(9, 9); // 18

for (let args of work.calls) {
  console.log( 'call:' + args.join() ); // "call:1,2", "call:4,5"
}
```